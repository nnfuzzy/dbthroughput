(def dt (t/date-time 2014 01 01))
(defn mean [coll]
(let [sum ( apply + coll)
count (count coll)
(if (pos? count)
(/ sum count)
0)))
(def dt (t/date-time 2014 01 01))
*clojure-version*
( 10 12 34)
(10 12 34)
'(10 12 34)
{"a" 1 "b" 2}
(let x {"a" 1 "b" 2})
(let (x {"a" 1 "b" 2}))
(let x map("a" 1 "b" 2))
(map("a" 1 "b" 2))
map("a" 1 "b" 2)
{"a" 1 "b" 2}
(let m {"a" 1 "b" 2})
(let m [{"a" 1 "b" 2]})
(let m [{"a" 1 "b" 2}])
(def m {"a" 1 "b" 2})
m
(get m ['a'])
(get m ["b"])
(get m ["a"])
(prn a)
(prn m)
(defn maker-adder [x] 
(let [y x]
(fn [z] (+ y z))))
(def add2 (make-adder 2))
(defn maker-adder [x] 
(let (x x]
(fn [z] (+ y z))))
(fn [z] (+ y z)))
(defn make-adder [x]
  (let [y x]
    (fn [z] (+ y z))))
(def add2 (make-adder 2))
(add2 4)
(add2 10)
(* 86400 360)
(* 60 24  360)
(require '[clj-time.core :as time]
         '[clj-time.coerce :as tc])
(tc/to-date (t/now))
(tc/to-long (t/now))
(tc/to-long (tc/now))
(tc/to-long (time/now))
(tc/to-long (tc/now))
(tc/to-long (time/now))
(require '[clj-time.core :as t]
         '[clj-time.coerce :as tc])
(tc/to-long (t/now))
(tc/to-long (tc/to-date (t/now)))
(println (doseq [item (range 1 100)] item)
)
(def num (range 1 1000))
(def nu (range 1 1000))
nu
(def nu (range 1 1000))
(println (doseq [i nu] i)
nu
)
(println (doseq [i nu] i))
(doseq [i nu] i)
nu
(def nu (range 1 10))
nu
(doseq [i nu] nu)
(doseq [i nu] println nu)
(prn (doseq [i nu] i)
)
(println (doseq [i range(1 100)] i)
)
(do (doseq[item nu] item))
nu)
(do (doseq[item nu] item))
nu
(doseq [item nu] (println item))
(require  '[monger.core :as mg]
          '[monger.collection :as mc]
          '[clj-time.periodic :as time-period]
          '[clj-time.core :as time]
          '[clj-time.local :as tl]
          '[clj-time.format :as tf]
          '[clj-time.coerce :as tc]
          '[clj-time.periodic :as tp])
(def custom-formatter (tf/formatter "yyyy-mm-dd"))
(tf/parse custom-formatter "2010-03-11")
(tc/to-long (tf/parse custom-formatter "2010-03-11"))
(require  '[monger.core :as mg]
          '[monger.collection :as mc]
          '[clj-time.periodic :as time-period]
          '[clj-time.core :as time]
          '[clj-time.local :as tl]
          '[clj-time.format :as tf]
          '[clj-time.coerce :as tc]
          '[clj-time.periodic :as tp])
(def abbr-day (tf/formatter "E"))
(tf/unparse abbr-day (t/now))
(tf/unparse abbr-day (time/now))
(hash-map :key1 1 :key2 2)
(def m hash-map :key1 1 :key2 2)
(def m  (hash-map :key1 1 :key2 2))
m
(get m :key1)
(get m :key1 :key2)
(get m :key1)
((get m :key1) (get m :key2))
(get m :key1)
(get m :key2)
(map (get m))
(map get m)
(= (zipmap (keys m) (vals m)) m)
(get :key1)
(get m :key1)
(keys  m)
(vals m)
(times (doseq [item (range 1 10000)]))
(time (doseq [item (range 1 10000)]))
(/ 86 4)
(* 86400 360)
(/ 10 (* 86400 360))
( / 10 (* 86400 360))
(* 86400 360)
(def s (* 86400 360))
s
(/ s 10 )
( /  (* 86400 360) 10 )
(( /  (* 86400 360) 10 )
)
( /  ( /  (* 86400 360) 1000000 )
( /  ( /  (* 86400 360) 1000 )
)
(def s ( /  ( /  (* 86400 360) 1000 )))
s
(def s ( /  ( /  (* 86400 360) 30 )))
s
(def s ( /  (* 86400 360) 30 ))
s
